name: Sync Upstream & Publish

# 每天 UTC 8:00（北京时间 16:00）自动检测上游新版本
# 也可通过 Actions 页面手动触发
on:
  schedule:
    - cron: "0 8 * * *"
  workflow_dispatch:

concurrency:
  group: sync-upstream
  cancel-in-progress: false

env:
  UPSTREAM_REPO: https://github.com/openclaw/openclaw.git
  CNB_REGISTRY: https://npm.cnb.cool/mugglezack/openclaw-cb/-/packages/
  NODE_VERSION: "22"

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Check upstream version
        id: check
        run: |
          set -euo pipefail

          # 获取官方最新版本（从 npm 公共 registry）
          UPSTREAM_VER="$(npm view openclaw version --registry=https://registry.npmjs.org/)"
          echo "upstream_version=${UPSTREAM_VER}" >> "$GITHUB_OUTPUT"

          # 获取本地基准版本（去掉 -codebuddy.N 后缀）
          LOCAL_VER="$(node -p "require('./package.json').version")"
          BASE_VER="$(echo "${LOCAL_VER}" | sed 's/-codebuddy\..*//')"
          echo "local_version=${LOCAL_VER}" >> "$GITHUB_OUTPUT"
          echo "base_version=${BASE_VER}" >> "$GITHUB_OUTPUT"

          echo "上游版本: ${UPSTREAM_VER}"
          echo "本地版本: ${LOCAL_VER} (基准: ${BASE_VER})"

          if [ "${UPSTREAM_VER}" = "${BASE_VER}" ]; then
            echo "已是最新版本，无需同步。"
            echo "needs_sync=false" >> "$GITHUB_OUTPUT"
          else
            echo "检测到新版本，开始同步。"
            echo "needs_sync=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Merge upstream
        if: steps.check.outputs.needs_sync == 'true'
        id: merge
        run: |
          set -euo pipefail

          UPSTREAM_VER="${{ steps.check.outputs.upstream_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git remote add upstream "${{ env.UPSTREAM_REPO }}" || true
          git fetch upstream --tags

          # 尝试通过 tag 合并，如果 tag 不存在则用 main 分支
          TAG="v${UPSTREAM_VER}"
          if git rev-parse "upstream/tags/${TAG}" &>/dev/null; then
            MERGE_REF="${TAG}"
          elif git tag -l "${TAG}" | grep -q "${TAG}"; then
            MERGE_REF="${TAG}"
          else
            echo "Tag ${TAG} 不存在，使用 upstream/main"
            MERGE_REF="upstream/main"
          fi

          echo "合并目标: ${MERGE_REF}"

          if git merge "${MERGE_REF}" --no-edit; then
            echo "merge_success=true" >> "$GITHUB_OUTPUT"
          else
            echo "检测到冲突，尝试自动解决..."

            # 获取冲突文件列表
            CONFLICTED="$(git diff --name-only --diff-filter=U)"
            echo "冲突文件: ${CONFLICTED}"

            # 检查是否只有可自动解决的文件冲突
            # 允许的冲突来源：
            #   - 构建/依赖: package.json, pnpm-lock.yaml, .npmrc
            #   - CI workflows: .github/workflows/*（保留 fork 版本）
            #   - 源文件: src/*（接受上游版本，后续 patch 注入 codebuddy）
            #   - 配置/文档: README.md, tsconfig, vitest 等
            UNEXPECTED=""
            for f in ${CONFLICTED}; do
              case "${f}" in
                package.json|pnpm-lock.yaml|.npmrc)
                  echo "可自动解决 (依赖/配置): ${f}"
                  ;;
                .github/workflows/*)
                  echo "可自动解决 (CI workflow，保留 fork): ${f}"
                  ;;
                src/*)
                  echo "可自动解决 (源文件，接受上游): ${f}"
                  ;;
                README.md|CHANGELOG.md|tsconfig*.json|vitest*.ts|*.config.ts)
                  echo "可自动解决 (配置/文档): ${f}"
                  ;;
                *)
                  UNEXPECTED="${UNEXPECTED} ${f}"
                  ;;
              esac
            done

            if [ -n "${UNEXPECTED}" ]; then
              echo "::error::以下文件存在无法自动解决的冲突:${UNEXPECTED}"
              git merge --abort
              echo "merge_success=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            # package.json: 接受上游版本，稍后会覆写 name/version/publishConfig
            if echo "${CONFLICTED}" | grep -q "^package.json$"; then
              git checkout --theirs package.json
              git add package.json
            fi

            # pnpm-lock.yaml: 接受上游版本，稍后 pnpm install 会重新生成
            if echo "${CONFLICTED}" | grep -q "^pnpm-lock.yaml$"; then
              git checkout --theirs pnpm-lock.yaml
              git add pnpm-lock.yaml
            fi

            # .npmrc: 保留 fork 版本（包含 CNB registry 配置）
            if echo "${CONFLICTED}" | grep -q "^\.npmrc$"; then
              git checkout --ours .npmrc
              git add .npmrc
            fi

            # .github/workflows/*: 保留 fork 版本（已禁用/已适配的 workflows）
            # src/*: 接受上游版本（后续 Update version 步骤会 patch 注入 codebuddy 代码）
            for f in ${CONFLICTED}; do
              if [[ "${f}" == .github/workflows/* ]]; then
                git checkout --ours "${f}"
                git add "${f}"
              elif [[ "${f}" == src/* ]]; then
                git checkout --theirs "${f}"
                git add "${f}"
              elif [[ "${f}" == README.md ]] || [[ "${f}" == CHANGELOG.md ]] || [[ "${f}" == tsconfig*.json ]] || [[ "${f}" == vitest*.ts ]] || [[ "${f}" == *.config.ts ]]; then
                git checkout --theirs "${f}"
                git add "${f}"
              fi
            done

            # 完成合并
            git -c core.editor=true merge --continue
            echo "冲突已自动解决"
            echo "merge_success=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Update version
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        run: |
          set -euo pipefail

          UPSTREAM_VER="${{ steps.check.outputs.upstream_version }}"
          NEW_VER="${UPSTREAM_VER}-codebuddy.1"

          # 更新 package.json: 恢复 fork 的 name/publishConfig/依赖 + 设置新版本号
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.name = 'openclaw';
            pkg.version = '${NEW_VER}';
            pkg.publishConfig = {
              registry: '${{ env.CNB_REGISTRY }}'
            };
            if (!pkg.dependencies['@tencent-ai/agent-sdk']) {
              pkg.dependencies['@tencent-ai/agent-sdk'] = '^0.3.57';
            }
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          # 确保 onboard-types.ts 包含 codebuddy AuthChoiceGroupId 和 AuthChoice
          node -e '
            const fs = require("fs");
            const file = "src/commands/onboard-types.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              content = content.replace(
                /(\| "xai")/,
                "| \"codebuddy\"\n  $1"
              );
              content = content.replace(
                /(\| "custom-api-key")/,
                "| \"codebuddy\"\n  $1"
              );
              fs.writeFileSync(file, content);
              console.log("Added codebuddy to AuthChoiceGroupId and AuthChoice");
            }
          '

          # 确保 register.onboard.ts 的 --auth-choice 帮助文本包含 codebuddy
          # 上游 v2026.2.14+ 用 AUTH_CHOICE_HELP 常量（由 formatAuthChoiceChoicesForCli 动态生成），
          # codebuddy 会通过 auth-choice-options.ts 的 patch 自动包含，无需额外修改。
          # 仅当旧版本使用硬编码字符串时才需要 patch。
          node -e '
            const fs = require("fs");
            const file = "src/cli/program/register.onboard.ts";
            let content = fs.readFileSync(file, "utf8");
            // 如果已使用动态生成的 AUTH_CHOICE_HELP，codebuddy 由 auth-choice-options patch 处理
            if (content.includes("formatAuthChoiceChoicesForCli")) {
              console.log("register.onboard.ts uses dynamic AUTH_CHOICE_HELP, skipping patch");
            } else if (!content.includes("codebuddy")) {
              // 旧版本：硬编码字符串，需要注入 codebuddy
              if (content.match(/Auth:.*\|chutes\|/)) {
                content = content.replace(/(\|chutes\|)(openai-codex|vllm)/, "$1codebuddy|$2");
              } else if (content.match(/Auth:.*\|vllm\|/)) {
                content = content.replace(/(\|vllm\|)(openai-codex)/, "$1codebuddy|$2");
              }
              fs.writeFileSync(file, content);
              console.log("Patched --auth-choice help text with codebuddy");
            }
          '

          # 确保 README.md 顶部包含 CodeBuddy 安装/更新说明
          node -e '
            const fs = require("fs");
            const file = "README.md";
            let content = fs.readFileSync(file, "utf8");
            const marker = "## CodeBuddy 版本安装/更新";
            if (!content.includes(marker)) {
              const block = [
                "",
                "## CodeBuddy 版本安装/更新",
                "",
                "```bash",
                "# 一键安装",
                "npm install -g openclaw@latest --registry=https://npm.cnb.cool/mugglezack/openclaw-cb/-/packages/",
                "",
                "# 更新到最新版",
                "npm i -g openclaw@latest --registry=https://npm.cnb.cool/mugglezack/openclaw-cb/-/packages/",
                "",
                "# 安装后运行 onboard 向导",
                "openclaw onboard --auth-choice codebuddy",
                "```",
                "",
              ].join("\n");
              // 插入到 EXFOLIATE 行之后
              const anchor = "</p>\n\n<p align=\"center\">";
              const idx = content.indexOf(anchor);
              if (idx !== -1) {
                const insertAt = idx + "</p>".length;
                content = content.slice(0, insertAt) + "\n" + block + content.slice(insertAt);
              } else {
                // fallback: 插入到第一个 ## 之前
                const firstH2 = content.indexOf("\n## ");
                if (firstH2 !== -1) {
                  content = content.slice(0, firstH2) + "\n" + block + content.slice(firstH2);
                }
              }
              fs.writeFileSync(file, content);
              console.log("Injected CodeBuddy install section into README.md");
            }
          '

          # 确保 onboard-auth.credentials.ts 包含 setCodeBuddyProfile 函数
          node -e '
            const fs = require("fs");
            const file = "src/commands/onboard-auth.credentials.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("setCodeBuddyProfile")) {
              const fn = [
                "",
                "export function setCodeBuddyProfile(agentDir?: string) {",
                "  upsertAuthProfile({",
                "    profileId: \"codebuddy:default\",",
                "    credential: {",
                "      type: \"api_key\",",
                "      provider: \"codebuddy\",",
                "      key: \"codebuddy-sdk-local\",",
                "    },",
                "    agentDir: resolveAuthAgentDir(agentDir),",
                "  });",
                "}",
                "",
              ].join("\n");
              content = content.trimEnd() + "\n" + fn;
              fs.writeFileSync(file, content);
              console.log("Added setCodeBuddyProfile to onboard-auth.credentials.ts");
            }
          '

          # 确保 onboard-auth.ts 导出 setCodeBuddyProfile
          node -e '
            const fs = require("fs");
            const file = "src/commands/onboard-auth.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("setCodeBuddyProfile")) {
              content = content.replace(
                /(writeOAuthCredentials,)/,
                "setCodeBuddyProfile,\n  $1"
              );
              fs.writeFileSync(file, content);
              console.log("Added setCodeBuddyProfile export to onboard-auth.ts");
            }
          '

          # 确保 auth-choice-options.ts 包含 codebuddy 分组和选项
          node -e '
            const fs = require("fs");
            const file = "src/commands/auth-choice-options.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              content = content.replace(
                /(\{\s*value: "custom",)/,
                "{\n    value: \"codebuddy\",\n    label: \"CodeBuddy\",\n    hint: \"Local CLI — no API key needed\",\n    choices: [\"codebuddy\"],\n  },\n  $1"
              );
              content = content.replace(
                /(options\.push\(\{ value: "custom-api-key")/,
                "options.push({ value: \"codebuddy\", label: \"CodeBuddy (local CLI)\", hint: \"No API key needed\" });\n  $1"
              );
              fs.writeFileSync(file, content);
              console.log("Added codebuddy to auth-choice-options.ts");
            }
          '

          # 确保 auth-choice.preferred-provider.ts 包含 codebuddy 映射
          node -e '
            const fs = require("fs");
            const file = "src/commands/auth-choice.preferred-provider.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              content = content.replace(
                /("custom-api-key": "custom")/,
                "codebuddy: \"codebuddy\",\n  $1"
              );
              fs.writeFileSync(file, content);
              console.log("Added codebuddy to auth-choice.preferred-provider.ts");
            }
          '

          # 确保 auth-choice.apply.ts 包含 codebuddy handler
          node -e '
            const fs = require("fs");
            const file = "src/commands/auth-choice.apply.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              content = content.replace(
                /(import \{ applyAuthChoiceXAI \} from "\.\/auth-choice\.apply\.xai\.js";)/,
                "$1\nimport { applyAuthProfileConfig, setCodeBuddyProfile } from \"./onboard-auth.js\";"
              );
              content = content.replace(
                /(applyAuthChoiceAnthropic,)/,
                "async (p) => {\n      if (p.authChoice !== \"codebuddy\") {\n        return null;\n      }\n      setCodeBuddyProfile(p.agentDir);\n      const config = applyAuthProfileConfig(p.config, {\n        profileId: \"codebuddy:default\",\n        provider: \"codebuddy\",\n        mode: \"api_key\",\n      });\n      return { config };\n    },\n    $1"
              );
              fs.writeFileSync(file, content);
              console.log("Added codebuddy handler to auth-choice.apply.ts");
            }
          '

          # ============================================================
          # Agents 目录 Patch: 注入 CodeBuddy provider 核心实现
          # ============================================================

          # Patch: src/agents/model-auth.ts — 在 resolveApiKeyForProvider 中注入 CodeBuddy 早期返回
          node -e '
            const fs = require("fs");
            const file = "src/agents/model-auth.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              const anchor = "const store = params.store ?? ensureAuthProfileStore(params.agentDir);";
              const idx = content.indexOf(anchor);
              if (idx === -1) { console.error("model-auth.ts: anchor not found"); process.exit(1); }
              const injection = [
                "  // CodeBuddy SDK communicates with local CLI process, no API key needed",
                "  const normalized = normalizeProviderId(provider);",
                "  if (normalized === \"codebuddy\") {",
                "    return {",
                "      apiKey: \"codebuddy-sdk-local\",",
                "      source: \"codebuddy-sdk-local\",",
                "      mode: \"api-key\",",
                "    };",
                "  }",
                "",
                "  "
              ].join("\n");
              content = content.slice(0, idx) + injection + content.slice(idx);
              // Remove the duplicate "const normalized = normalizeProviderId(provider);" after store
              const storeEnd = content.indexOf(anchor) + anchor.length;
              const rest = content.slice(storeEnd);
              const dupLine = "\n\n  const normalized = normalizeProviderId(provider);";
              if (rest.startsWith(dupLine)) {
                content = content.slice(0, storeEnd) + rest.slice(dupLine.length);
              }
              fs.writeFileSync(file, content);
              console.log("Patched model-auth.ts: injected CodeBuddy early return");
            }
          '

          # Patch: src/agents/models-config.providers.ts — 注入 CODEBUDDY_DEFAULT_COST 常量
          node -e '
            const fs = require("fs");
            const file = "src/agents/models-config.providers.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("CODEBUDDY_DEFAULT_COST")) {
              const anchor = "interface OllamaModel {";
              const idx = content.indexOf(anchor);
              if (idx === -1) { console.error("providers.ts: OllamaModel anchor not found"); process.exit(1); }
              const injection = [
                "// CodeBuddy provider constants (IOA version — all models are free)",
                "const CODEBUDDY_DEFAULT_COST = {",
                "  input: 0,",
                "  output: 0,",
                "  cacheRead: 0,",
                "  cacheWrite: 0,",
                "};",
                "",
                ""
              ].join("\n");
              content = content.slice(0, idx) + injection + content.slice(idx);
              fs.writeFileSync(file, content);
              console.log("Patched providers.ts: injected CODEBUDDY_DEFAULT_COST");
            }
          '

          # Patch: src/agents/models-config.providers.ts — 注入 buildCodeBuddyProvider() 函数
          node -e '
            const fs = require("fs");
            const file = "src/agents/models-config.providers.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("buildCodeBuddyProvider")) {
              const anchor = "export async function resolveImplicitProviders(params: {";
              const idx = content.indexOf(anchor);
              if (idx === -1) { console.error("providers.ts: resolveImplicitProviders anchor not found"); process.exit(1); }
              const models = [
                { id: "claude-opus-4.6", name: "Claude Opus 4.6", reasoning: true, input: ["text","image"], cw: 176000, mt: 24000 },
                { id: "claude-opus-4.5", name: "Claude Opus 4.5", reasoning: true, input: ["text","image"], cw: 176000, mt: 24000 },
                { id: "claude-4.5", name: "Claude Sonnet 4.5", reasoning: true, input: ["text","image"], cw: 176000, mt: 24000 },
                { id: "claude-haiku-4.5", name: "Claude Haiku 4.5", reasoning: true, input: ["text","image"], cw: 176000, mt: 24000 },
                { id: "gpt-5.2", name: "GPT-5.2", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gpt-5.2-codex", name: "GPT-5.2 Codex", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gpt-5.1", name: "GPT-5.1", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gpt-5.1-codex", name: "GPT-5.1 Codex", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gpt-5.1-codex-max", name: "GPT-5.1 Codex Max", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gpt-5.1-codex-mini", name: "GPT-5.1 Codex Mini", reasoning: true, input: ["text","image"], cw: 272000, mt: 128000 },
                { id: "gemini-3.0-pro", name: "Gemini 3.0 Pro", reasoning: true, input: ["text","image"], cw: 400000, mt: 64000 },
                { id: "gemini-3.0-flash", name: "Gemini 3.0 Flash", reasoning: true, input: ["text","image"], cw: 400000, mt: 64000 },
                { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro", reasoning: true, input: ["text","image"], cw: 400000, mt: 64000 },
                { id: "deepseek-v3-2-volc-ioa", name: "DeepSeek V3.2", reasoning: true, input: ["text"], cw: 96000, mt: 32000 },
                { id: "minimax-m2.5-ioa", name: "MiniMax M2.5", reasoning: true, input: ["text"], cw: 200000, mt: 48000 },
                { id: "kimi-k2.5-ioa", name: "Kimi K2.5", reasoning: true, input: ["text","image"], cw: 164000, mt: 32000 },
                { id: "kimi-k2-thinking", name: "Kimi K2 Thinking", reasoning: true, input: ["text"], cw: 164000, mt: 32000 },
                { id: "glm-5.0-ioa", name: "GLM 5.0", reasoning: true, input: ["text"], cw: 200000, mt: 48000 },
                { id: "glm-4.7-ioa", name: "GLM 4.7", reasoning: true, input: ["text"], cw: 160000, mt: 48000 },
                { id: "glm-4.6v-ioa", name: "GLM 4.6V", reasoning: true, input: ["text","image"], cw: 128000, mt: 32000 },
                { id: "glm-4.6-ioa", name: "GLM 4.6", reasoning: true, input: ["text"], cw: 168000, mt: 32000 }
              ];
              const modelLines = models.map(m =>
                "      {\n" +
                "        id: \"" + m.id + "\",\n" +
                "        name: \"" + m.name + "\",\n" +
                "        reasoning: " + m.reasoning + ",\n" +
                "        input: [" + m.input.map(i => "\"" + i + "\"").join(", ") + "],\n" +
                "        cost: CODEBUDDY_DEFAULT_COST,\n" +
                "        contextWindow: " + m.cw + ",\n" +
                "        maxTokens: " + m.mt + ",\n" +
                "      }"
              ).join(",\n");
              const fn = [
                "/**",
                " * Build the CodeBuddy provider configuration.",
                " * Model list and parameters sourced from @tencent-ai/agent-sdk cli/product.ioa.json.",
                " */",
                "export function buildCodeBuddyProvider(): ProviderConfig {",
                "  return {",
                "    // CodeBuddy uses a local CLI process via SDK, not a standard HTTP API.",
                "    // This URL is a placeholder; the actual call goes through the SDK adapter.",
                "    baseUrl: \"codebuddy-sdk://local\",",
                "    api: \"anthropic-messages\",",
                "    models: [",
                modelLines,
                "    ],",
                "  };",
                "}",
                "",
                ""
              ].join("\n");
              content = content.slice(0, idx) + fn + content.slice(idx);
              fs.writeFileSync(file, content);
              console.log("Patched providers.ts: injected buildCodeBuddyProvider()");
            }
          '

          # Patch: src/agents/models-config.providers.ts — 在 resolveImplicitProviders 中注入 codebuddy 注册逻辑
          node -e '
            const fs = require("fs");
            const file = "src/agents/models-config.providers.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("provider: \"codebuddy\"")) {
              // Find the resolveImplicitProviders function body
              const fnStart = content.indexOf("export async function resolveImplicitProviders(");
              if (fnStart === -1) { console.error("providers.ts: resolveImplicitProviders not found"); process.exit(1); }
              // Find "return providers;" within this function (search from fnStart)
              const fnBody = content.slice(fnStart);
              const retIdx = fnBody.lastIndexOf("return providers;");
              if (retIdx === -1) { console.error("providers.ts: return providers not found"); process.exit(1); }
              const absIdx = fnStart + retIdx;
              const injection = [
                "  // CodeBuddy SDK communicates with local CLI process, no API key needed.",
                "  // Register when the user has a codebuddy auth profile or explicit config.",
                "  const codebuddyKey = resolveApiKeyFromProfiles({ provider: \"codebuddy\", store: authStore });",
                "  if (codebuddyKey) {",
                "    providers.codebuddy = { ...buildCodeBuddyProvider(), apiKey: codebuddyKey };",
                "  }",
                "",
                "  "
              ].join("\n");
              content = content.slice(0, absIdx) + injection + content.slice(absIdx);
              fs.writeFileSync(file, content);
              console.log("Patched providers.ts: injected codebuddy registration in resolveImplicitProviders");
            }
          '

          # Patch: src/agents/pi-embedded-runner/run/attempt.ts — 注入 CodeBuddy import
          node -e '
            const fs = require("fs");
            const file = "src/agents/pi-embedded-runner/run/attempt.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy-stream-adapter")) {
              const anchor = "import { resolveOpenClawDocsPath } from \"../../docs-path.js\";";
              const idx = content.indexOf(anchor);
              if (idx === -1) { console.error("attempt.ts: docs-path import anchor not found"); process.exit(1); }
              const injection = "import { createCodeBuddyStreamFn, isCodeBuddyProvider } from \"../../codebuddy-stream-adapter.js\";\n";
              content = content.slice(0, idx) + injection + content.slice(idx);
              fs.writeFileSync(file, content);
              console.log("Patched attempt.ts: injected CodeBuddy import");
            }
          '

          # Patch: src/agents/pi-embedded-runner/run/attempt.ts — 在 Ollama 检查前注入 CodeBuddy provider 检查
          node -e '
            const fs = require("fs");
            const file = "src/agents/pi-embedded-runner/run/attempt.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("isCodeBuddyProvider")) {
              const anchor = "if (params.model.api === \"ollama\") {";
              const idx = content.indexOf(anchor);
              if (idx === -1) { console.error("attempt.ts: ollama check anchor not found"); process.exit(1); }
              const injection = [
                "// For CodeBuddy provider, use the custom adapter that wraps the CodeBuddy SDK.",
                "      if (isCodeBuddyProvider(params.provider)) {",
                "        // CodeBuddy SDK communicates with local CLI process, no API key needed",
                "        activeSession.agent.streamFn = createCodeBuddyStreamFn();",
                "      } else "
              ].join("\n");
              content = content.slice(0, idx) + injection + content.slice(idx);
              fs.writeFileSync(file, content);
              console.log("Patched attempt.ts: injected CodeBuddy provider check before Ollama");
            }
          '

          # Patch: src/agents/models-config.skips-writing-models-json-no-env-token.e2e.test.ts — 修改测试名称和断言
          node -e '
            const fs = require("fs");
            const file = "src/agents/models-config.skips-writing-models-json-no-env-token.e2e.test.ts";
            let content = fs.readFileSync(file, "utf8");
            if (!content.includes("codebuddy")) {
              // 替换测试名称
              content = content.replace(
                "skips writing models.json when no env token or profile exists",
                "writes only codebuddy provider when no env token or profile exists"
              );
              // 替换断言: expect(result.wrote).toBe(false) → true + 读取并检查 providers
              const oldAssert = "expect(result.wrote).toBe(false);";
              if (content.includes(oldAssert)) {
                const newAssert = [
                  "// CodeBuddy provider is always registered (no API key needed),",
                  "        // so models.json is written with at least that provider.",
                  "        expect(result.wrote).toBe(true);",
                  "        const raw = await fs.readFile(path.join(agentDir, \"models.json\"), \"utf8\");",
                  "        const parsed = JSON.parse(raw) as { providers: Record<string, unknown> };",
                  "        expect(Object.keys(parsed.providers)).toEqual([\"codebuddy\"]);"
                ].join("\n");
                content = content.replace(oldAssert, newAssert);
              }
              fs.writeFileSync(file, content);
              console.log("Patched test file: updated test name and assertions for codebuddy");
            }
          '

          echo "版本号已更新为: ${NEW_VER}"

      - name: Install dependencies
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        run: pnpm install --frozen-lockfile || pnpm install

      - name: Build
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        run: pnpm build

      - name: Test
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        run: pnpm test
        continue-on-error: true

      - name: Publish to CNB
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        env:
          CNB_NPM_TOKEN: ${{ secrets.CNB_NPM_TOKEN }}
        run: |
          set -euo pipefail

          # 配置认证
          echo "//npm.cnb.cool/mugglezack/openclaw-cb/-/packages/:_authToken=${CNB_NPM_TOKEN}" >> ~/.npmrc

          # 发布（prerelease 版本需要 --tag latest）
          npm publish --registry="${{ env.CNB_REGISTRY }}" --tag latest

          NEW_VER="$(node -p "require('./package.json').version")"
          echo "已发布: openclaw@${NEW_VER}"

      - name: Commit & tag
        if: steps.check.outputs.needs_sync == 'true' && steps.merge.outputs.merge_success == 'true'
        run: |
          set -euo pipefail

          NEW_VER="$(node -p "require('./package.json').version")"

          git add -A
          git commit -m "chore: sync upstream v${{ steps.check.outputs.upstream_version }} → ${NEW_VER}" || true
          git tag "v${NEW_VER}"
          git push origin HEAD --tags

      - name: Summary
        if: always()
        run: |
          echo "## 同步结果" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- 上游版本: \`${{ steps.check.outputs.upstream_version }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- 本地基准: \`${{ steps.check.outputs.base_version }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- 需要同步: \`${{ steps.check.outputs.needs_sync }}\`" >> "$GITHUB_STEP_SUMMARY"
          if [ "${{ steps.check.outputs.needs_sync }}" = "true" ]; then
            echo "- 合并状态: \`${{ steps.merge.outputs.merge_success || 'N/A' }}\`" >> "$GITHUB_STEP_SUMMARY"
          fi
